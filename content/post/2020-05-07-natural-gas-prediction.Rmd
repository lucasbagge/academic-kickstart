---
title: Natural gas prediction
author: Lucas Bagge
date: '2020-05-07'
slug: natural-gas-prediction
categories:
  - tidymodels
  - energi prices
  - time seres
tags:
  - tidymodels
  - energi prices
  - time series
subtitle: 'Price prediction univarite stochastic level using tidymodels'
summary: ''
authors: []
lastmod: '2020-05-07T05:41:08+02:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, message = FALSE, 
                      echo = TRUE, dpi = 300, cache.lazy = FALSE,
                      tidy = "styler", fig.width = 8, fig.height = 5)
library(scales)
library(tidyverse)
library(quantmod)
library(tidymodels)
library(magrittr)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(forecast)
library(scales)
library(tseries)
```
# Introduction

For many time series models the biggst task is to make forcast for the future.
In a so called **state space analysis** the time series observations are assumed to
depend linearly on a state vector, which are generated by a stochastic dynamic process.
The observations are also assumed to subject to measurment error and independent 
of the state vector. Therfore the two main component is the observed and unobserved 
states of the data. 

Kalman filter is a smooth function der estimere mean niveau, where the serie fluctuate
around. I think about a time variation equlibirum. it is a mean that can variate 
over time. den betinget middelværdi der ahænger af tiden. Hvis du har estimere
det sturkturelle niveau og har en afvigelse du ligger over det, så vil du forvente
en mean revertion. 

# Data and visualization

We will be using the functionality of `quantmod` to get data for the natural gas.

```{r}
ng <- getSymbols(
  "NG",
  auto.assign = FALSE
)
tail(ng)
```

A quick vizual interpretation for the data can be used with the same package.

```{r}
barChart(ng)
```

The series look non-stationary and very volatile. It can also be spotted that
there is some sesonality in the data, where we have a spike in the winter period.

For our analysis I am gonna use Close prices. For making the computinal a litlle 
easier the analysis is maded for monthly data.

```{r}
ng_close <- Cl(ng)

ng_close_month <- apply.monthly(ng_close, mean)

ng_close_month_tidy <- tidy(ng_close_month)

plot(ng_close_month)
```

When we work with statistical modelling they often rely on a **normal distribution**
by that I mean  a distribution that is symmetric and has a bell shape. 

```{r}
ng_close_month_tidy %>% 
  ggplot(
    aes(
      x = value
    ) 
  ) +
  geom_histogram(
    aes(
      y = ..density..
    ),
    position = 'identity', 
    binwidth = 1,
    colour = "black",
    fill = "turquoise",
    alpha = 0.6 
  ) +
  geom_density(
    alpha = 0.6,
    fill = "#FF6666"
  ) +
  scale_color_brewer(
    palette = "Accent"
  ) +
  theme_pubclean() +
  labs(title = "Weight density curve",
       x = "Price",
       y = "Density")

```

```{r}
ng_close_month_tidy %>% 
  ggqqplot(
    x = "value",
    palette = "#FC4E07",
    ggtheme = theme_pubclean()
  )
```

From the density and QQ plot it is clear to see that we don´t have a normal
distribution

## Stationarity test

We can almost immently say that the time series is not statinary. For a
ananlyis os this see the following graph,

```{r}
ng_close_month_tidy %>% 
  ggplot(
    aes(
      x = index, 
      y = value)) +
  geom_line(
    color = "indianred3", 
    size = 1) +
  geom_smooth() +
  labs(title = "Natural Gas",
       subtitle = "2000 to 2020",
       x = "",
       y = "Close price") +
  theme_minimal()
```

```{r}
ggplot.corr <- function(data, lag.max = 24, ci = 0.95, large.sample.size = TRUE, horizontal = TRUE,...) {
  
  require(ggplot2)
  require(dplyr)
  require(cowplot)
  
  if(horizontal == TRUE) {numofrow <- 1} else {numofrow <- 2}
  
  list.acf <- acf(data, lag.max = lag.max, type = "correlation", plot = FALSE)
  N <- as.numeric(list.acf$n.used)
  df1 <- data.frame(lag = list.acf$lag, acf = list.acf$acf)
  df1$lag.acf <- dplyr::lag(df1$acf, default = 0)
  df1$lag.acf[2] <- 0
  df1$lag.acf.cumsum <- cumsum((df1$lag.acf)^2)
  df1$acfstd <- sqrt(1/N * (1 + 2 * df1$lag.acf.cumsum))
  df1$acfstd[1] <- 0
  df1 <- select(df1, lag, acf, acfstd)
  
  list.pacf <- acf(data, lag.max = lag.max, type = "partial", plot = FALSE)
  df2 <- data.frame(lag = list.pacf$lag,pacf = list.pacf$acf)
  df2$pacfstd <- sqrt(1/N)
  
  if(large.sample.size == TRUE) {
    plot.acf <- ggplot(data = df1, aes( x = lag, y = acf)) +
    geom_area(aes(x = lag, y = qnorm((1+ci)/2)*acfstd), fill = "#B9CFE7") +
    geom_area(aes(x = lag, y = -qnorm((1+ci)/2)*acfstd), fill = "#B9CFE7") +
    geom_col(fill = "#4373B6", width = 0.7) +
    scale_x_continuous(breaks = seq(0,max(df1$lag),6)) +
    scale_y_continuous(name = element_blank(), 
                       limits = c(min(df1$acf,df2$pacf),1)) +
    ggtitle("ACF") +
    theme_bw()
    
    plot.pacf <- ggplot(data = df2, aes(x = lag, y = pacf)) +
    geom_area(aes(x = lag, y = qnorm((1+ci)/2)*pacfstd), fill = "#B9CFE7") +
    geom_area(aes(x = lag, y = -qnorm((1+ci)/2)*pacfstd), fill = "#B9CFE7") +
    geom_col(fill = "#4373B6", width = 0.7) +
    scale_x_continuous(breaks = seq(0,max(df2$lag, na.rm = TRUE),6)) +
    scale_y_continuous(name = element_blank(),
                       limits = c(min(df1$acf,df2$pacf),1)) +
    ggtitle("PACF") +
    theme_bw()
  }
  else {
    plot.acf <- ggplot(data = df1, aes( x = lag, y = acf)) +
    geom_col(fill = "#4373B6", width = 0.7) +
    geom_hline(yintercept = qnorm((1+ci)/2)/sqrt(N), 
               colour = "sandybrown",
               linetype = "dashed") + 
    geom_hline(yintercept = - qnorm((1+ci)/2)/sqrt(N), 
               colour = "sandybrown",
               linetype = "dashed") + 
    scale_x_continuous(breaks = seq(0,max(df1$lag),6)) +
    scale_y_continuous(name = element_blank(), 
                       limits = c(min(df1$acf,df2$pacf),1)) +
    ggtitle("ACF") +
    theme_bw()
    
    plot.pacf <- ggplot(data = df2, aes(x = lag, y = pacf)) +
    geom_col(fill = "#4373B6", width = 0.7) +
    geom_hline(yintercept = qnorm((1+ci)/2)/sqrt(N), 
               colour = "sandybrown",
               linetype = "dashed") + 
    geom_hline(yintercept = - qnorm((1+ci)/2)/sqrt(N), 
               colour = "sandybrown",
               linetype = "dashed") + 
    scale_x_continuous(breaks = seq(0,max(df2$lag, na.rm = TRUE),6)) +
    scale_y_continuous(name = element_blank(),
                       limits = c(min(df1$acf,df2$pacf),1)) +
    ggtitle("PACF") +
    theme_bw()
  }
  cowplot::plot_grid(plot.acf, plot.pacf, nrow = numofrow)
}
```

```{r}
ng_close_month_ts = ts(ng_close_month$NG.Close,
                       start = c(2007, 1),
                       end = c(2020, 5),
                       frequency = 12)
ggplot.corr(data = ng_close_month_ts,
            lag.max = 10,
            ci = 0.95, 
            large.sample.size = TRUE,
            horizontal = TRUE)

```

```{r}
adf.test(ng_close_month_ts)  
pp.test(ng_close_month_ts)
kpss.test(ng_close_month_ts)

ptibble <- tribble(
  ~ Test, ~ "P-value",
  "ADF", 0.5116,
  "PP",  0.6207,
  "KPSS", 0.01
)
ptibble %>% 
  kable()
```
From our stationary test the conclusion is that the time serie is not statinory.


